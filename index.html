<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ArrowWord vs AI</title>
    <!-- Tailwind CSS para estructura r√°pida -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FontAwesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- ESTILO CSS PERSONALIZADO -->
    <style>
        :root {
            --grid-cols: 8;
            --grid-rows: 10;
            --cell-size: clamp(35px, 9vw, 55px);
            --clue-bg: #e0f2fe; /* Azul muy suave */
            --clue-text: #0ea5e9;
            --border-color: #334155;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8fafc;
            touch-action: manipulation; /* Mejor respuesta t√°ctil */
        }

        /* TABLERO */
        .game-board {
            display: grid;
            grid-template-columns: repeat(var(--grid-cols), var(--cell-size));
            grid-template-rows: repeat(var(--grid-rows), var(--cell-size));
            gap: 1px;
            background-color: var(--border-color);
            border: 2px solid var(--border-color);
            margin: 0 auto;
            user-select: none;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }

        .cell {
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            position: relative;
            text-transform: uppercase;
        }

        /* CELDAS DE PISTA */
        .cell.clue-cell {
            background-color: var(--clue-bg);
            color: #1e293b;
            font-size: 0.65rem;
            font-weight: normal;
            padding: 2px;
            text-align: center;
            flex-direction: column;
            line-height: 1.1;
            z-index: 10;
        }

        /* Flechas indicadoras en las pistas */
        .arrow-right::after {
            content: '‚Æï';
            display: block;
            color: var(--clue-text);
            font-size: 0.8rem;
            margin-top: 1px;
        }
        .arrow-down::after {
            content: '‚¨á';
            display: block;
            color: var(--clue-text);
            font-size: 0.8rem;
            margin-top: 1px;
        }

        /* CELDAS DE JUEGO */
        .cell.game-cell {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .cell.game-cell.filled-ai {
            color: #ef4444; /* Color rojo para la IA */
            background-color: #fef2f2;
        }

        .cell.game-cell.filled-player {
            color: #2563eb; /* Color azul para el Jugador */
            background-color: #eff6ff;
        }
        
        .cell.game-cell.correct-flash {
            animation: flashGreen 0.5s ease-out;
        }

        .cell.game-cell.error-shake {
            animation: shake 0.4s ease-in-out;
            background-color: #fee2e2;
        }

        /* BANCO DE LETRAS DEL JUGADOR */
        .rack-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            padding: 15px;
            min-height: 80px;
        }

        .tile {
            width: 50px;
            height: 50px;
            background-color: #ffffff;
            border: 2px solid #cbd5e1;
            border-bottom: 4px solid #94a3b8;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e293b;
            cursor: grab;
            touch-action: none; /* Importante para drag en m√≥vil */
            user-select: none;
            transition: transform 0.1s;
        }

        .tile:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .tile.dragging {
            opacity: 0.5;
        }

        /* UI GENERICA */
        .score-box {
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .score-change {
            position: absolute;
            font-weight: bold;
            font-size: 1.2rem;
            animation: floatUp 1s forwards;
            pointer-events: none;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-20px); opacity: 0; }
        }

        @keyframes flashGreen {
            0% { background-color: #86efac; }
            100% { background-color: #eff6ff; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Modal Overlay */
        .modal-overlay {
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(2px);
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- HEADER: PUNTUACI√ìN Y TURNO -->
    <header class="bg-white shadow-sm p-4 z-20">
        <div class="max-w-2xl mx-auto flex justify-between items-center">
            
            <!-- Jugador -->
            <div class="flex flex-col items-center score-box" id="player-score-box">
                <span class="text-xs text-gray-500 uppercase font-bold tracking-wider">T√∫</span>
                <div class="text-3xl font-black text-blue-600" id="score-player">0</div>
            </div>

            <!-- Info Central -->
            <div class="flex flex-col items-center">
                <div id="turn-indicator" class="px-4 py-1 rounded-full bg-blue-100 text-blue-800 text-sm font-bold mb-1">
                    Tu Turno
                </div>
                <div class="text-xs text-gray-400">Nivel: <span id="level-display" class="font-bold text-gray-600">F√°cil</span></div>
            </div>

            <!-- IA -->
            <div class="flex flex-col items-center score-box" id="ai-score-box">
                <span class="text-xs text-gray-500 uppercase font-bold tracking-wider">IA</span>
                <div class="text-3xl font-black text-red-500" id="score-ai">0</div>
            </div>
        </div>
    </header>

    <!-- √ÅREA DE JUEGO (Scrollable) -->
    <main class="flex-1 overflow-auto p-4 flex items-center justify-center bg-gray-50">
        <div id="board" class="game-board shadow-xl rounded-lg overflow-hidden">
            <!-- Grid generated by JS -->
        </div>
    </main>

    <!-- CONTROLES DEL JUGADOR -->
    <footer class="bg-white border-t border-gray-200 p-4 z-20">
        <div class="max-w-2xl mx-auto">
            <div class="text-center text-gray-400 text-xs mb-2">Arrastra las letras a la cuadr√≠cula</div>
            
            <div id="rack" class="rack-container bg-gray-100 rounded-xl mb-4 shadow-inner">
                <!-- Tiles generated by JS -->
            </div>

            <div class="flex gap-2">
                <button onclick="game.passTurn()" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-3 px-4 rounded-lg transition">
                    Pasar Turno
                </button>
                <button onclick="game.shuffleRack()" class="w-12 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold rounded-lg flex items-center justify-center">
                    <i class="fa-solid fa-shuffle"></i>
                </button>
            </div>
        </div>
    </footer>

    <!-- MODAL DE INICIO / SELECCI√ìN DE NIVEL -->
    <div id="start-modal" class="modal-overlay fixed inset-0 flex items-center justify-center z-50">
        <div class="bg-white rounded-2xl shadow-2xl p-8 max-w-sm w-full mx-4 text-center">
            <h1 class="text-2xl font-black text-gray-800 mb-2">Crucigrama VS IA</h1>
            <p class="text-gray-500 mb-6">Completa las palabras antes que la m√°quina.</p>
            
            <div class="space-y-3">
                <button onclick="game.start('easy')" class="w-full bg-green-100 hover:bg-green-200 text-green-700 font-bold py-3 rounded-lg border border-green-300 transition flex items-center justify-center gap-2">
                    <span>üê£</span> F√°cil
                </button>
                <button onclick="game.start('medium')" class="w-full bg-yellow-100 hover:bg-yellow-200 text-yellow-700 font-bold py-3 rounded-lg border border-yellow-300 transition flex items-center justify-center gap-2">
                    <span>ü§î</span> Intermedio
                </button>
                <button onclick="game.start('hard')" class="w-full bg-red-100 hover:bg-red-200 text-red-700 font-bold py-3 rounded-lg border border-red-300 transition flex items-center justify-center gap-2">
                    <span>ü§ñ</span> Dif√≠cil
                </button>
            </div>
        </div>
    </div>

    <!-- L√ìGICA JAVASCRIPT -->
    <script>
        // --- 1. DATOS (VOCABULARIO) ---
        // Pegamos aqu√≠ el JSON optimizado que generamos
        const VOCABULARY = [
            { "palabra": "yo", "traduccion_ingles": "I üôã" },
            { "palabra": "tu", "traduccion_ingles": "you üëâ" },
            { "palabra": "el", "traduccion_ingles": "he üë®" },
            { "palabra": "sol", "traduccion_ingles": "‚òÄÔ∏è" },
            { "palabra": "pan", "traduccion_ingles": "ü•ñ" },
            { "palabra": "luz", "traduccion_ingles": "üí°" },
            { "palabra": "casa", "traduccion_ingles": "üè†" },
            { "palabra": "gato", "traduccion_ingles": "üê±" },
            { "palabra": "agua", "traduccion_ingles": "üíß" },
            { "palabra": "rojo", "traduccion_ingles": "üî¥" },
            { "palabra": "azul", "traduccion_ingles": "üîµ" },
            { "palabra": "mesa", "traduccion_ingles": "ü™ë" },
            { "palabra": "libro", "traduccion_ingles": "üìñ" },
            { "palabra": "perro", "traduccion_ingles": "üê∂" },
            { "palabra": "feliz", "traduccion_ingles": "üòÑ" },
            { "palabra": "padre", "traduccion_ingles": "üë®" },
            { "palabra": "madre", "traduccion_ingles": "üë©" },
            { "palabra": "coche", "traduccion_ingles": "üöó" },
            { "palabra": "playa", "traduccion_ingles": "üèñÔ∏è" },
            { "palabra": "verde", "traduccion_ingles": "üü¢" },
            { "palabra": "noche", "traduccion_ingles": "üåô" },
            { "palabra": "comer", "traduccion_ingles": "üçΩÔ∏è" },
            { "palabra": "beber", "traduccion_ingles": "ü•§" },
            { "palabra": "amigo", "traduccion_ingles": "ü§õ" },
            { "palabra": "lunes", "traduccion_ingles": "Monday" },
            { "palabra": "abuelo", "traduccion_ingles": "üë¥" },
            { "palabra": "dinero", "traduccion_ingles": "üí∞" },
            { "palabra": "escuela", "traduccion_ingles": "üè´" },
            { "palabra": "trabajo", "traduccion_ingles": "üíº" },
            { "palabra": "familia", "traduccion_ingles": "üë®‚Äçüë©‚Äçüëß" },
            { "palabra": "manzana", "traduccion_ingles": "üçé" },
            { "palabra": "semana", "traduccion_ingles": "week" },
            { "palabra": "tiempo", "traduccion_ingles": "weather" },
            { "palabra": "comida", "traduccion_ingles": "food" },
            { "palabra": "ciudad", "traduccion_ingles": "üèôÔ∏è" },
            { "palabra": "musica", "traduccion_ingles": "üéµ" } // Sin tildes para simplificar el juego A1
        ];

        // --- 2. CLASE GRID SYSTEM (Generaci√≥n del tablero) ---
        class GridSystem {
            constructor(rows, cols) {
                this.rows = rows;
                this.cols = cols;
                this.grid = Array(rows).fill().map(() => Array(cols).fill(null));
                // Matriz de soluci√≥n (letras correctas)
                this.solution = Array(rows).fill().map(() => Array(cols).fill(null));
                // Estado actual del tablero (letras puestas por jugadores)
                this.currentState = Array(rows).fill().map(() => Array(cols).fill(null));
                
                this.words = []; // Lista de objetos {word, r, c, dir, hint}
            }

            // Para asegurar que el juego funcione, usaremos un layout predefinido robusto
            // C = Clue, . = Espacio vac√≠o
            generateLayout() {
                // Limpiar
                this.grid = Array(this.rows).fill().map(() => Array(this.cols).fill(null));
                this.solution = Array(this.rows).fill().map(() => Array(this.cols).fill(''));
                
                // Definir palabras manualmente para garantizar cruces en esta demo 
                // (En una version completa, esto ser√≠a un algoritmo de backtracking)
                
                const layoutWords = [
                    // Horizontales
                    { word: "ESCUELA", r: 1, c: 1, dir: 'h', hint: "üè´" },
                    { word: "ROJO", r: 3, c: 1, dir: 'h', hint: "üî¥" },
                    { word: "GATO", r: 3, c: 6, dir: 'h', hint: "üê±" }, // Requiere pista interna
                    { word: "FAMILIA", r: 5, c: 1, dir: 'h', hint: "üë®‚Äçüë©‚Äçüëß" },
                    { word: "AGUA", r: 7, c: 2, dir: 'h', hint: "üíß" },
                    { word: "SOL", r: 9, c: 5, dir: 'h', hint: "‚òÄÔ∏è" },

                    // Verticales
                    { word: "PERRO", r: 1, c: 1, dir: 'v', hint: "üê∂" },
                    { word: "COCHE", r: 1, c: 3, dir: 'v', hint: "üöó" },
                    { word: "LIBRO", r: 1, c: 5, dir: 'v', hint: "üìñ" },
                    { word: "AUTO", r: 1, c: 7, dir: 'v', hint: "üöó (LatAm)" }, // Cruza con Gato
                    { word: "CASA", r: 3, c: 2, dir: 'v', hint: "üè†" }, 
                    { word: "AMIGO", r: 5, c: 4, dir: 'v', hint: "ü§õ" },
                    { word: "LUZ", r: 5, c: 6, dir: 'v', hint: "üí°" },
                    { word: "PAN", r: 7, c: 7, dir: 'v', hint: "ü•ñ" }
                ];

                layoutWords.forEach(w => this.placeWord(w));
                this.fillClueCells();
            }

            placeWord(w) {
                const len = w.word.length;
                // Guardar la palabra en la lista l√≥gica
                this.words.push(w);

                // Escribir en la matriz de soluci√≥n
                for(let i=0; i<len; i++) {
                    let r = w.r + (w.dir === 'v' ? i : 0);
                    let c = w.c + (w.dir === 'h' ? i : 0);
                    this.solution[r][c] = w.word[i];
                    this.grid[r][c] = { type: 'game', char: w.word[i] }; // Marcamos como celda de juego
                }
            }

            fillClueCells() {
                // L√≥gica para colocar las celdas de pista basadas en donde empiezan las palabras
                this.words.forEach(w => {
                    let clueR = w.r;
                    let clueC = w.c;

                    if (w.dir === 'h') clueC = w.c - 1;
                    if (w.dir === 'v') clueR = w.r - 1;

                    // Si ya existe una celda ah√≠, la actualizamos, si no, la creamos
                    if (!this.grid[clueR][clueC] || this.grid[clueR][clueC].type !== 'clue') {
                        this.grid[clueR][clueC] = { type: 'clue', hints: {} };
                    }

                    // A√±adir la pista
                    if (w.dir === 'h') this.grid[clueR][clueC].hints.right = w.hint;
                    if (w.dir === 'v') this.grid[clueR][clueC].hints.down = w.hint;
                });
                
                // Rellenar el resto de vac√≠os con bloques negros o decorativos si fuera necesario
                // Para simplificar, lo que sea null se renderiza como bloque vac√≠o/negro
            }

            getEmptyCells() {
                let empties = [];
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        // Si es celda de juego Y no tiene letra puesta por usuario/IA
                        if (this.grid[r][c]?.type === 'game' && !this.currentState[r][c]) {
                            empties.push({r, c, correctChar: this.solution[r][c]});
                        }
                    }
                }
                return empties;
            }
        }

        // --- 3. L√ìGICA DEL JUEGO (GAME ENGINE) ---
        class Game {
            constructor() {
                this.gridSystem = new GridSystem(10, 8);
                this.score = { player: 0, ai: 0 };
                this.difficulty = 'easy';
                this.playerRack = [];
                this.isPlayerTurn = true; // Empieza el jugador
                this.selectedTile = null;
            }

            init() {
                this.gridSystem.generateLayout();
                this.renderGrid();
                this.fillPlayerRack();
                // Ocultar modal
                document.getElementById('start-modal').style.display = 'none';
            }

            start(diff) {
                this.difficulty = diff;
                document.getElementById('level-display').textContent = 
                    diff === 'easy' ? 'F√°cil' : diff === 'medium' ? 'Intermedio' : 'Dif√≠cil';
                this.init();
            }

            // --- Renderizado ---
            renderGrid() {
                const board = document.getElementById('board');
                board.innerHTML = ''; // Limpiar

                for(let r=0; r<10; r++) {
                    for(let c=0; c<8; c++) {
                        const cellData = this.gridSystem.grid[r][c];
                        const div = document.createElement('div');
                        div.className = 'cell';
                        div.dataset.r = r;
                        div.dataset.c = c;

                        if (cellData && cellData.type === 'clue') {
                            div.classList.add('clue-cell');
                            let html = '';
                            if (cellData.hints.right) html += `<div class="arrow-right mb-1">${cellData.hints.right}</div>`;
                            if (cellData.hints.down) html += `<div class="arrow-down">${cellData.hints.down}</div>`;
                            div.innerHTML = html;
                        } 
                        else if (cellData && cellData.type === 'game') {
                            div.classList.add('game-cell');
                            // Eventos Drop
                            div.ondragover = (e) => e.preventDefault();
                            div.ondrop = (e) => this.handleDrop(e, r, c);
                            div.onclick = () => this.handleTouchCell(r, c); // Para tap en m√≥vil tras seleccionar letra

                            // Mostrar letra si ya est√° puesta
                            const currentVal = this.gridSystem.currentState[r][c];
                            if (currentVal) {
                                div.textContent = currentVal.char;
                                div.classList.add(currentVal.owner === 'ai' ? 'filled-ai' : 'filled-player');
                            }
                        } else {
                            // Celda vac√≠a (bloque)
                            div.style.backgroundColor = '#cbd5e1';
                        }
                        board.appendChild(div);
                    }
                }
            }

            renderRack() {
                const rack = document.getElementById('rack');
                rack.innerHTML = '';
                this.playerRack.forEach((char, index) => {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.textContent = char;
                    tile.draggable = true;
                    
                    // Eventos Drag Desktop
                    tile.ondragstart = (e) => {
                        e.dataTransfer.setData('text/plain', char);
                        e.dataTransfer.setData('index', index);
                        tile.classList.add('dragging');
                    };
                    tile.ondragend = () => tile.classList.remove('dragging');

                    // Eventos Click/Touch (Selecci√≥n)
                    tile.onclick = () => {
                        // Deseleccionar otros
                        document.querySelectorAll('.tile').forEach(t => t.style.borderColor = '#cbd5e1');
                        if (this.selectedTile === index) {
                            this.selectedTile = null; // Deseleccionar
                        } else {
                            this.selectedTile = index;
                            tile.style.borderColor = '#3b82f6'; // Azul selecci√≥n
                            tile.style.transform = 'translateY(-5px)';
                        }
                    };

                    rack.appendChild(tile);
                });
            }

            // --- L√≥gica de Juego ---
            
            fillPlayerRack() {
                // Llenar hasta tener 5 letras
                // ESTRATEGIA: Dar letras √∫tiles (del tablero) + algo de ruido
                const emptyCells = this.gridSystem.getEmptyCells();
                
                while(this.playerRack.length < 5 && emptyCells.length > 0) {
                    // 70% probabilidad de letra √∫til, 30% aleatoria
                    if (Math.random() < 0.7) {
                        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                        this.playerRack.push(randomCell.correctChar);
                    } else {
                        const abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                        this.playerRack.push(abc[Math.floor(Math.random() * abc.length)]);
                    }
                }
                this.renderRack();
            }

            handleDrop(e, r, c) {
                e.preventDefault();
                if (!this.isPlayerTurn) return;

                const char = e.dataTransfer.getData('text/plain');
                const index = e.dataTransfer.getData('index');
                
                this.attemptMove(r, c, char, parseInt(index));
            }

            handleTouchCell(r, c) {
                if (!this.isPlayerTurn || this.selectedTile === null) return;
                
                const char = this.playerRack[this.selectedTile];
                this.attemptMove(r, c, char, this.selectedTile);
                this.selectedTile = null; // Reset selecci√≥n
            }

            attemptMove(r, c, char, rackIndex) {
                // Verificar si la celda es v√°lida y est√° vac√≠a
                const cellData = this.gridSystem.grid[r][c];
                const currentVal = this.gridSystem.currentState[r][c];

                if (!cellData || cellData.type !== 'game' || currentVal) return;

                // 1. Quitar letra del rack
                this.playerRack.splice(rackIndex, 1);
                
                // 2. Colocar en tablero
                const isCorrect = (char === this.gridSystem.solution[r][c]);
                
                // Animaci√≥n y l√≥gica
                const cellDiv = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
                
                if (isCorrect) {
                    this.gridSystem.currentState[r][c] = { char: char, owner: 'player' };
                    cellDiv.textContent = char;
                    cellDiv.classList.add('filled-player', 'correct-flash');
                    this.updateScore('player', 1);
                    this.checkWordCompletion(r, c, 'player');
                } else {
                    // Error: Penalizaci√≥n y no se pone la ficha (se pierde)
                    cellDiv.classList.add('error-shake');
                    setTimeout(() => cellDiv.classList.remove('error-shake'), 500);
                    this.updateScore('player', -1);
                }

                this.renderRack(); // Actualizar mano
                
                // Verificar si gan√≥ o acab√≥ turno (Opcional: pasar turno tras 1 movimiento o dejar seguir)
                // En este dise√±o: El jugador juega hasta que quiera pasar o se quede sin letras.
                // Pero para dinamismo, recargamos rack si se vac√≠a.
                if (this.playerRack.length === 0) this.fillPlayerRack();
            }

            checkWordCompletion(r, c, who) {
                // Verificar palabras horizontales y verticales que pasan por (r,c)
                // Buscamos en this.gridSystem.words las que pasan por aqu√≠
                const words = this.gridSystem.words.filter(w => {
                    if (w.dir === 'h') return w.r === r && c >= w.c && c < w.c + w.word.length;
                    if (w.dir === 'v') return w.c === c && r >= w.r && r < w.r + w.word.length;
                    return false;
                });

                words.forEach(w => {
                    // Verificar si la palabra est√° completa en currentState
                    let isComplete = true;
                    for(let i=0; i<w.word.length; i++) {
                        let cr = w.r + (w.dir === 'v' ? i : 0);
                        let cc = w.c + (w.dir === 'h' ? i : 0);
                        if (!this.gridSystem.currentState[cr][cc]) {
                            isComplete = false;
                            break;
                        }
                    }

                    if (isComplete) {
                        // Bonus!
                        const points = w.word.length; // Puntos por longitud
                        this.updateScore(who, points);
                        // Feedback visual (podr√≠a iluminar toda la palabra, omitido por brevedad)
                    }
                });
            }

            updateScore(who, points) {
                this.score[who] += points;
                const el = document.getElementById(`score-${who}`);
                el.textContent = this.score[who];
                
                // Animaci√≥n flotante
                const box = document.getElementById(`${who}-score-box`);
                const float = document.createElement('div');
                float.className = 'score-change text-' + (who==='player'?'blue':'red') + '-600';
                float.textContent = points > 0 ? `+${points}` : points;
                box.appendChild(float);
                setTimeout(() => float.remove(), 1000);
            }

            passTurn() {
                if (!this.isPlayerTurn) return;
                this.isPlayerTurn = false;
                document.getElementById('turn-indicator').textContent = "Turno IA...";
                document.getElementById('turn-indicator').className = "px-4 py-1 rounded-full bg-red-100 text-red-800 text-sm font-bold mb-1";
                
                // Simular pensamiento IA
                setTimeout(() => ai.makeMove(), 1500);
            }

            shuffleRack() {
                if(!this.isPlayerTurn) return;
                // Fisher-Yates shuffle
                for (let i = this.playerRack.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.playerRack[i], this.playerRack[j]] = [this.playerRack[j], this.playerRack[i]];
                }
                this.renderRack();
            }
        }

        // --- 4. INTELIGENCIA ARTIFICIAL ---
        class AI {
            makeMove() {
                const empties = game.gridSystem.getEmptyCells();
                if (empties.length === 0) {
                    alert("¬°Juego Terminado!");
                    return;
                }

                let movesToMake = 0;
                let moveType = 'random';

                // Configurar comportamiento seg√∫n dificultad
                if (game.difficulty === 'easy') {
                    movesToMake = Math.random() > 0.5 ? 2 : 1;
                    moveType = 'random';
                } 
                else if (game.difficulty === 'hard') {
                    movesToMake = Math.floor(Math.random() * 3) + 3; // 3 a 5
                    moveType = 'best';
                }
                else { // Medium
                    movesToMake = Math.floor(Math.random() * 2) + 2; // 2 a 3
                    moveType = Math.random() > 0.5 ? 'best' : 'random';
                }

                this.performMoves(movesToMake, moveType, empties);
            }

            performMoves(count, type, availableCells) {
                if (count <= 0 || availableCells.length === 0) {
                    this.endTurn();
                    return;
                }

                let selectedCell = null;

                if (type === 'random') {
                    const idx = Math.floor(Math.random() * availableCells.length);
                    selectedCell = availableCells[idx];
                    // Quitar de disponibles
                    availableCells.splice(idx, 1);
                } 
                else if (type === 'best') {
                    // L√ìGICA VORAZ (GREEDY)
                    // Calcular puntos potenciales de cada celda vac√≠a
                    let bestScore = -1;
                    let bestIdx = -1;

                    availableCells.forEach((cell, idx) => {
                        let potentialPoints = 1; // +1 por letra
                        
                        // Simular que ponemos la letra y ver si completa palabra
                        // (Nota: Esto es una simplificaci√≥n de la l√≥gica checkWordCompletion)
                        // Aqu√≠ asumimos que la IA "sabe" qu√© palabras completar√≠a
                        
                        // Check horizontal y vertical neighbors en la soluci√≥n
                        // Si neighbors + esta celda == longitud palabra, puntos extra
                        // Esto requiere revisar game.gridSystem.words
                        
                        const wordsAffected = game.gridSystem.words.filter(w => {
                            // Check si cell est√° dentro de word w
                            if (w.dir === 'h') return w.r === cell.r && cell.c >= w.c && cell.c < w.c + w.word.length;
                            if (w.dir === 'v') return w.c === cell.c && cell.r >= w.r && cell.r < w.r + w.word.length;
                            return false;
                        });

                        wordsAffected.forEach(w => {
                            // Contar huecos vac√≠os en esa palabra
                            let gaps = 0;
                            for(let i=0; i<w.word.length; i++) {
                                let cr = w.r + (w.dir === 'v' ? i : 0);
                                let cc = w.c + (w.dir === 'h' ? i : 0);
                                // Si est√° vac√≠a Y no es la celda que estamos evaluando
                                if (!game.gridSystem.currentState[cr][cc] && !(cr===cell.r && cc===cell.c)) {
                                    gaps++;
                                }
                            }
                            if (gaps === 0) potentialPoints += w.word.length; // Completa palabra
                        });

                        if (potentialPoints > bestScore) {
                            bestScore = potentialPoints;
                            bestIdx = idx;
                        }
                    });

                    selectedCell = availableCells[bestIdx];
                    availableCells.splice(bestIdx, 1);
                }

                // Ejecutar movimiento visualmente
                const {r, c, correctChar} = selectedCell;
                game.gridSystem.currentState[r][c] = { char: correctChar, owner: 'ai' };
                
                // Actualizar UI
                const cellDiv = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
                cellDiv.textContent = correctChar;
                cellDiv.classList.add('filled-ai');
                
                game.updateScore('ai', 1);
                game.checkWordCompletion(r, c, 'ai');

                // Siguiente movimiento con delay para efecto "tecleando"
                setTimeout(() => {
                    this.performMoves(count - 1, type, availableCells);
                }, 800);
            }

            endTurn() {
                game.isPlayerTurn = true;
                document.getElementById('turn-indicator').textContent = "Tu Turno";
                document.getElementById('turn-indicator').className = "px-4 py-1 rounded-full bg-blue-100 text-blue-800 text-sm font-bold mb-1";
                game.fillPlayerRack(); // Rellenar letras del jugador si le faltan
            }
        }

        // INICIALIZACI√ìN
        const game = new Game();
        const ai = new AI();
        
        // Prevenir scroll en m√≥viles al arrastrar
        document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });

    </script>
</body>
</html>
